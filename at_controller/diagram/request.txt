Я составил еще классы для условий

@dataclass(kw_only=True)
class OperationCondition(Condition):
    type: str
    condition: Optional[Union[EquatationCondition, InclusionCondition, AndCondition, OrCondition, 'NotCondition', 'NonArgOperationCondition', 'BinaryOperationCondition']] = field(default=None)
    
    def perform_operation(self, checking_value, state_machine: 'StateMachine'):
        pass
    
    def check(self, checking_value: Any, state_machine: 'StateMachine'):
        v = self.perform_operation(checking_value, state_machine)
        if self.condition is not None:
            return self.condition.check(v, state_machine)
        return v
    
    
@dataclass(kw_only=True)
class NonArgOperationCondition(OperationCondition):
    type: Literal[
        'len', 'sqrt', 'abs', 'ceil', 'floor', 'round', 'sign', 'log', 'exp',
        'sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'neg', 'transpose', 
        'det', 'inv', 'norm', 'trace', 'is_null'
    ]
    
    def perform_operation(self, checking_value, state_machine: 'StateMachine'):
        if self.type == 'len':
            return len(checking_value)
        elif self.type == 'sqrt':
            return math.sqrt(checking_value)
        elif self.type == 'abs':
            return abs(checking_value)
        elif self.type == 'ceil':
            return math.ceil(checking_value)
        elif self.type == 'floor':
            return math.floor(checking_value)
        elif self.type == 'round':
            return round(checking_value)
        elif self.type == 'sign':
            return math.copysign(1, checking_value)
        elif self.type == 'log':
            return math.log(checking_value)
        elif self.type == 'exp':
            return math.exp(checking_value)
        elif self.type == 'sin':
            return math.sin(checking_value)
        elif self.type == 'cos':
            return math.cos(checking_value)
        elif self.type == 'tan':
            return math.tan(checking_value)
        elif self.type == 'asin':
            return math.asin(checking_value)
        elif self.type == 'acos':
            return math.acos(checking_value)
        elif self.type == 'atan':
            return math.atan(checking_value)
        elif self.type == 'neg':
            return -checking_value
        elif self.type == 'transpose':
            return np.transpose(checking_value)
        elif self.type == 'det':
            return np.linalg.det(checking_value)
        elif self.type == 'inv':
            return np.linalg.inv(checking_value)
        elif self.type == 'norm':
            return np.linalg.norm(checking_value)
        elif self.type == 'trace':
            return np.trace(checking_value)
        elif self.type == 'is_null':
            return checking_value is None
        else:
            raise ValueError(f"Unsupported operation type: {self.type}")

@dataclass(kw_only=True)
class BinaryOperationCondition(OperationCondition):
    type: Literal[
        'add', 'sub', 'mul', 'div', 'mod', 'pow', 'logical_and', 'logical_or', 'xor', 
        'max', 'min', 'equal', 'not_equal', 'less_than', 'less_or_equal', 
        'greater_than', 'greater_or_equal', 'state_attr'
    ]
    argument: Any

    def perform_operation(self, checking_value, state_machine: 'StateMachine'):
        if self.type == 'add':
            return checking_value + self.argument
        elif self.type == 'sub':
            return checking_value - self.argument
        elif self.type == 'mul':
            return checking_value * self.argument
        elif self.type == 'div':
            return checking_value / self.argument
        elif self.type == 'mod':
            return checking_value % self.argument
        elif self.type == 'pow':
            return checking_value ** self.argument
        elif self.type == 'logical_and':
            return checking_value and self.argument
        elif self.type == 'logical_or':
            return checking_value or self.argument
        elif self.type == 'xor':
            return operator.xor(checking_value, self.argument)
        elif self.type == 'max':
            return max(checking_value, self.argument)
        elif self.type == 'min':
            return min(checking_value, self.argument)
        elif self.type == 'equal':
            return checking_value == self.argument
        elif self.type == 'not_equal':
            return checking_value != self.argument
        elif self.type == 'less_than':
            return checking_value < self.argument
        elif self.type == 'less_or_equal':
            return checking_value <= self.argument
        elif self.type == 'greater_than':
            return checking_value > self.argument
        elif self.type == 'greater_or_equal':
            return checking_value >= self.argument
        elif self.type =='state_attr':
            return state_machine.attributes.get(self.argument)
        else:
            raise ValueError(f"Unsupported operation type: {self.type}")


И имеются следующие pydantic модели для парсинга

class EquatationConditionModel(BaseModel):
    type: Literal['eq', 'ne', 'gt', 'gte', 'lt', 'lte']
    value: Any
    
    def to_internal(self) -> EquatationCondition:
        return EquatationCondition(type=self.type, value=self.value)
    

class InclusionConditionModel(BaseModel):
    type: Literal['in', 'not_in', 'includes', 'not_includes']
    value: Union[List[Any], Dict[Any, Any]]
    
    def to_internal(self) -> InclusionCondition:
        return InclusionCondition(type=self.type, value=self.value)


class AndConditionModel(BaseModel):
    type: Literal['and']
    conditions: List[Union['EquatationConditionModel', 'InclusionConditionModel', 'AndConditionModel', 'OrConditionModel', 'NotConditionModel']]

    def to_internal(self) -> AndCondition:
        return AndCondition(type='and', arguments=[cond.to_internal() for cond in self.conditions])


class OrConditionModel(BaseModel):
    type: Literal['or']
    conditions: List[Union['EquatationConditionModel', 'InclusionConditionModel', AndConditionModel, 'OrConditionModel', 'NotConditionModel']]
    
    def to_internal(self) -> OrCondition:
        return OrCondition(type='or', arguments=[cond.to_internal() for cond in self.conditions])
    

class NotConditionModel(BaseModel):
    type: Literal['not']
    condition: Union['EquatationConditionModel', 'InclusionConditionModel', 'AndConditionModel', 'OrConditionModel', 'NotConditionModel']

    def to_internal(self) -> NotCondition:
        return NotCondition(condition=self.condition.to_internal())
    

class EventTransitionModel(BaseModel):
    event: Optional[str] = Field(default=None)
    type: Literal['event'] = 'event'
    source: str
    dest: str
    handler_component: Optional[str]
    handler_method: Optional[str]
    trigger_condition: Optional[Union[EquatationConditionModel, InclusionConditionModel, AndConditionModel, OrConditionModel]]
    actions: List[Dict[str, Any]] = Field(default_factory=list)

    # Валидация для динамической обработки условий
    @model_validator(mode='before')
    def parse_conditions(cls, values):
        condition_data = values.get("trigger_condition")
        if condition_data:
            values["trigger_condition"] = cls.parse_condition(condition_data)
        return values

    @classmethod
    def parse_condition(cls, data: Dict[str, Any]) -> Union[EquatationConditionModel, InclusionConditionModel, AndConditionModel, OrConditionModel]:
        # Разбираем условия по ключам
        type = next(iter(data))
        if "and" in data:
            return AndConditionModel(type=type, conditions=[cls.parse_condition(cond) for cond in data["and"]])
        elif "or" in data:
            return OrConditionModel(type=type, conditions=[cls.parse_condition(cond) for cond in data["or"]])
        elif "in" in data or "not_in" in data or "includes" in data or "not_includes" in data:
            return InclusionConditionModel(type=type, value=data[type])
        elif "not" in data:
            return NotConditionModel(type='not', condition=cls.parse_condition(data["not"]))
        else:
            return EquatationConditionModel(type=type, value=data[type])


Нужно добавить модели для валидации всех операционных условий, учитывая, что тип операционных условий также является ключом
